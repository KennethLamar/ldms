
# ldms genders by node selfreported hostname needed for init.d control

# monitoring data collectors are ldmsd
atacoadmin1,ataco[1-4],ataco-login[1-4],atacogw[1-2] ldmsd,ldmsd_port=411,ldmsd_xprt=rdma
atacoadmin1,ataco[1-4] ldmsd_host=%n-ib0
#irregular naming in 'hostname' make this needed.
ataco-login1 ldmsd_host=atacologin1-ib0
ataco-login2 ldmsd_host=atacologin2-ib0
ataco-login3 ldmsd_host=atacologin3-ib0
ataco-login4 ldmsd_host=atacologin4-ib0
atacogw[1-2] ldmsd_host=%n-ib2

# aggregator 1st level
# bootnodelist is expanded to match bootnode values. See man page for alternatives.
# port 411 cannot be used for both ldms_aggd and ldmsd if xprt is the same.
ataco-login[1-4],atacogw[1-2],ataco[1-4] ldmsd_clientof=atacoadmin1
atacoadmin1 ldmsaggd=CLIENTOFLIST,ldmsaggd_port=411,ldmsaggd_host=ataco-admin1,ldmsaggd_xprt=sock,ldmsaggd_clientof=aries

aries ldmsaggd=AGGCLIENTOFLIST
aries ldmsaggd_port=411
aries ldmsaggd_host=aries.sandia.gov
aries ldmsaggd_xprt=sock
# future viz pipeline
aries ldmsaggd_clientof=perf1.sandia.gov
aries ldmsaggd_stores=store_csv
aries ldmsaggd_store_csv=altheader/1:rollover/3600:rolltype/1:id_pos/1
aries ldmsaggd_interval_default=1000000,ldmsaggd_offset_default=100000

# metric sets
atacoadmin1,ataco[1-4],ataco-login[1-4],atacogw[1-2] ldmsd_metric_sets=meminfo:vmstat:procnfs:procstatutil2:procnetdev:sysclassib

atacoadmin1,ataco[1-4],ataco-login[1-4],atacogw[1-2] ldmsd_procstatutil2=maxcpu/16
atacoadmin1,ataco[1-4],ataco-login[1-4],atacogw[1-2] ldmsd_procnetdev=ifaces/eth0&eth1&eth3&eth4&ib0&ib2

#atacoadmin1,ataco[1-4],ataco-login[1-4],atacogw[1-2] ldmsd_sysclassib=ports/qib0.1
#atacoadmin1,ataco[1-4],ataco-login[1-4],atacogw[1-2] ldmsd_sysclassib=ports/mlx4_0.1
#atacoadmin1,ataco[1-4],ataco-login[1-4] ldmsd_sysclassib=ports/mlx4_1.1

# make test agg hierarchy like so, then find sets. (d) indicates 
# collector on node that also hosts aggregator.
# (sock)|(-----------rdma-----------)
# top <- a2 <-----+ c2n3,pqv
#     | \a2(d)pqv |
#     |           + c2n4,pqv
#     |           + a1(d)pqv 
#     |           + a1 <---+ c1n1,pqv
#     |                    + c1n2,pqv
#     |
#     +- b2(d)tu
#     +- b2 <-+ b1(d)rs
#             + b1 <--+ c3n5,rs
#                     + c3n6,rs
#
## DEFINE local collector transport/port/host
c1n[1-2],c2n[3-4],c3n[5-6],a1,b1 ldmsd,ldmsd_host=%n-ib0,ldmsd_port=411,ldmsd_xprt=rdma
a2,b2 ldmsd,ldmsd_host=%n-eth0,ldmsd_port=411,ldmsd_xprt=sock
# DEFINE metric sets
c1n[1-2],c2n[3-4],a[1-2] ldmsd_metric_sets=p:q:v
c3n[5-6],b1 ldmsd_metric_sets=r:s
b2 ldmsd_metric_sets=t:u
# exclude set v from leaf nodes, but not from a2.
a[1-2],b[1-2] ldmsaggd_exclude_sets=v
# DEFINE aggregator port/host (HSN)
a1,b1 ldmsaggd_host=%n-ib1,ldmsaggd_port=412,ldmsaggd_xprt=rdma
# DEFINE aggregator ports/hosts (ext'l net)
a2,b2 ldmsaggd_host=%n-eth0,ldmsaggd_port=412,ldmsaggd_xprt=sock
## DEFINE COLLECTOR-AGG RELATIONS
# pq on leaf
c1n[1-2] ldmsd_clientof=a1
c2n[3-4] ldmsd_clientof=a2
# pq on dual agg/leaf a1(d)
a1 ldmsd_clientof=a2
# rs on leaf
c3n[5-6] ldmsd_clientof=b1
# rs on dual agg/leaf b1(d)
b1 ldmsd_clientof=b2
# tu on dual agg/leaf b2(d)
b2 ldmsd_clientof=top
# pq on dual agg/leaf a2(d)
a2 ldmsd_clientof=top
## DEFINE AGG-AGG RELATIONS
a1 ldmsaggd_clientof=a2
b1 ldmsaggd_clientof=b2
a2 ldmsaggd_clientof=top
b2 ldmsaggd_clientof=top
# Any explicit names in ldmsaggd are checked for collectors only, 
# which may not be expected by someone configure higher level aggregators
# assemble aggd lists via (AGG)CLIENTOFLIST
a1 ldmsaggd=CLIENTOFLIST
b1 ldmsaggd=CLIENTOFLIST
a2 ldmsaggd=CLIENTOFLIST:AGGCLIENTOFLIST
b2 ldmsaggd=CLIENTOFLIST:AGGCLIENTOFLIST
top ldmsaggd=CLIENTOFLIST:AGGCLIENTOFLIST
